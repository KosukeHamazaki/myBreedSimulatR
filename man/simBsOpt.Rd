% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mySimBsOpt.R
\name{simBsOpt}
\alias{simBsOpt}
\title{R6 Class Representing a Breeding Scheme}
\description{
simBsOpt object store specific information of simulation results of breeding scheme.
}
\examples{

## ------------------------------------------------
## Method `simBsOpt$new`
## ------------------------------------------------

### create simulation information
mySimInfo <- simInfo$new(simName = "Simulation Example",
                         simGeno = TRUE,
                         simPheno = TRUE,
                         #' nSimGeno = 1,
                         #' nSimPheno = 3,
                         #' nCoreMax = 4,
                         #' nCorePerGeno = 1,
                         #' nCorePerPheno = 3,
                         saveDataFileName = NULL)
### create specie information
mySpec <- specie$new(nChr = 3,
                     lChr = c(100, 150, 200),
                     specName = "Example 1",
                     ploidy = 2,
                     mutRate = 10^-8,
                     recombRate = 10^-6,
                     chrNames = c("C1", "C2", "C3"),
                     nLoci = 100,
                     recombRateOneVal = FALSE,
                     effPopSize = 100,
                     simInfo = mySimInfo,
                     verbose = TRUE)
### create lociInfo object
myLoci <- lociInfo$new(genoMap = NULL, specie = mySpec)
plot(myLoci, alpha = 0.1)
### create traitInfo object
myTrait <- traitInfo$new(lociInfo = myLoci,
                         nMarkers = 80,
                         nTraits = 3,
                         nQTLs = c(4, 8, 3),
                         actionTypeEpiSimple = TRUE,
                         qtlOverlap = TRUE,
                         nOverlap = c(2, 3, 0),
                         effCor = 0.1,
                         propDomi = 0.2,
                         interactionMean = c(4, 1, 2))
myTrait$plot(alphaMarker = 0.1)
### create bsInfo object
myBsInfo <- bsInfo$new(simInfo = mySimInfo,
                       specie = mySpec,
                       lociInfo = myLoci,
                       traitInfo = myTrait,
                       geno = NULL,
                       haplo = NULL,
                       founderIsInitPop = TRUE,
                       popNameBase = "Population",
                       initIndNames = NULL,
                       verbose = TRUE)
### create cross information object
for (i in 1:10) {
  myCrossInfo <- crossInfo$new(parentPopulation = myBsInfo$populations[[myBsInfo$generation]],
                               method = "randomMate",
                               nNextPop = 100)
  myBsInfo$nextGeneration(crossInfo = myCrossInfo)
}
geno <- myBsInfo$overGeneration()$genoMat
myBsInfo$print()
myBsInfo$plot(plotTarget = "trueAGV",
              targetTrait = 1:3,
              targetPopulation = 1:11,
              plotType = "jitter")

}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{simBsName}}{[character] Name of this simulation of breeding schemes}

\item{\code{bsInfoInit}}{[bsInfo] breeding scheme info
(see:\link[myBreedSimulatR]{bsInfo})}

\item{\code{breederInfoInit}}{[breederInfo] breeder info
(see:\link[myBreedSimulatR]{breederInfo})}

\item{\code{lociEffMethod}}{[character] How to compute loci effects (use true QTL effects ("true") or estimated marker effects ("estimated"))}

\item{\code{methodMLRInit}}{[character] Methods for estimating marker effects for initial population.
The following methods are offered:

"Ridge", "LASSO", "ElasticNet", "RR-BLUP", "GBLUP", "BayesA" (uni-trait),
"BayesB" (uni-trait), "BayesC" (uni-trait), "BRR", "BL" (uni-trait), "SpikeSlab" (multi-trait)}

\item{\code{multiTraitInit}}{[logical] Use multiple-trait model for estimation of marker effects or not for initial population}

\item{\code{nIterSimulation}}{[numeric] Number of iterations for this simulation setting}

\item{\code{nGenerationProceed}}{[numeric] Number of generations to be proceeded}

\item{\code{nGenerationProceedSimulation}}{[numeric] Number of generations to be proceeded in simulation for optimizing policy}

\item{\code{setGoalAsFinalGeneration}}{[logical] Set goal for simulation of breeding scheme as the real final generation}

\item{\code{performOptimization}}{[logical] Perform optimization of policy in each generation or not}

\item{\code{useFirstOptimizedValue}}{[logical] Perform optimization of policy only for the initial population and use the optimized hyperprameters permanently.}

\item{\code{sameAcrossGeneration}}{[logical] Use same hyper prameter across generations or not}

\item{\code{hMin}}{[numeric] Lower bound of hyper parameters}

\item{\code{hMax}}{[numeric] Upper bound of hyper parameters}

\item{\code{nTotalIterForOneOptimization}}{[numeric] Number of total iterations that can be assigned for one optimization process}

\item{\code{nIterSimulationPerEvaluation}}{[numeric] Number of simulations per one evaluation of the hyperparameter set of your interest}

\item{\code{nIterOptimization}}{[numeric] Number of iterations required for one optimization}

\item{\code{digitsEval}}{[numeric] When you evaluate each hyperparameter, you can round the average of evaluates (`eval`) with `round(eval, digitsEval)`.}

\item{\code{nRefreshMemoryEvery}}{[numeric] Every `nRefreshMemoryEvery` iterations, we refresh memory used for simulations by `gc(reset = TRUE)`.}

\item{\code{updateBreederInfo}}{[logical] Update breederInfo or not for each generation}

\item{\code{phenotypingInds}}{[logical] Phenotyping individuals or not for each generation}

\item{\code{nRepForPhenoInit}}{[numeric] Number of replications to be phenotyped for initial population}

\item{\code{nRepForPheno}}{[numeric] Number of replications to be phenotyped for each generation}

\item{\code{updateModels}}{[logical] Whether or not updating the model for each generation
(If `phenotypingInds = FALSE` for generation of your interest, `updateModels` will be automatically `FALSE` for that generation.)}

\item{\code{methodMLR}}{[character] Methods for estimating marker effects.
The following methods are offered:

"Ridge", "LASSO", "ElasticNet", "RR-BLUP", "GBLUP", "BayesA" (uni-trait),
"BayesB" (uni-trait), "BayesC" (uni-trait), "BRR", "BL" (uni-trait), "SpikeSlab" (multi-trait)}

\item{\code{multiTrait}}{[logical] Use multiple-trait model for estimation of marker effects or not}

\item{\code{nSelectionWaysVec}}{[numeric] Number of selection ways for each generation}

\item{\code{selectionMethodList}}{[list] (list of) Selection method for each generation}

\item{\code{traitNoSelList}}{[list] (list of list of) Number of trait No of your interest for selection for each generation}

\item{\code{blockSplitMethod}}{[character] How to determine the markers belonging to each block when computing OHV.
You can define the number of markers in each block (`nMrkInBlock`) or the minimum length of each segment (`minimumSegmentLength`).}

\item{\code{nMrkInBlock}}{[numeric] Number of markers in each block. This will be used for the computation of OHV.}

\item{\code{minimumSegmentLength}}{[numeric] Minimum length of each segment [cM]. This will be used for the computation of OHV.}

\item{\code{nIterOPV}}{[numeric] Number of iterations for computation of OPV}

\item{\code{nProgeniesEMBVVec}}{[numeric] Number of progenies of double haploids produced when computing EMBV for each generation}

\item{\code{nIterEMBV}}{[numeric] Number of iterations to estimate EMBV}

\item{\code{nCoresEMBV}}{[numeric] Number of cores used for EMBV estimation}

\item{\code{clusteringForSelList}}{[list] (list of) Apply clustering results of marker genotype to selection or not for each generation}

\item{\code{nClusterList}}{[list] (list of) Number of clusters for each generation}

\item{\code{nTopClusterList}}{[list] (list of) Number of top clusters used for selection for each generation}

\item{\code{nTopEachList}}{[list] (list of) Number of selected individuals in each cluster for each generation}

\item{\code{nSelList}}{[list] (list of) Number of selection candidates for each generation}

\item{\code{matingMethodVec}}{[character] Mating method for each generation}

\item{\code{allocateMethodVec}}{[character] Allocation method for each generation}

\item{\code{weightedAllocationMethodList}}{[list] (list of) Which selection index will be used for weighted resource allocation for each generation}

\item{\code{traitNoRAList}}{[list] (list of) Trait No of your interest for resource allocation for each generation}

\item{\code{includeGVPVec}}{[logical] Whether or not to consider genetic variance of progenies of each pair when determining the number of progenies per each pair for each generation}

\item{\code{nNextPopVec}}{[numeric] Number of progenies for the next generation  for each generation}

\item{\code{nameMethod}}{[character] Method for naming individuals}

\item{\code{nCores}}{[numeric] Number of cores used for simulations of breedinhh scheme}

\item{\code{nCoresPerOptimization}}{[numeric] Number of cores used for simulations of breeding scheme when optimizing hyperparameters}

\item{\code{overWriteRes}}{[logical] Overwrite simulation results when the targeted results already exists}

\item{\code{showProgress}}{[logical] Show progress bar or not}

\item{\code{returnMethod}}{[character] Which type of results will be returned (saved) in the object}

\item{\code{saveAllResAt}}{[character] If NULL, we won't save the simulation results. Else, we will save bsInfo and breederInfo for each iteration in the directory defined by `saveAllResAt` path.}

\item{\code{evaluateGVMethod}}{[character] Which type of GV (true GV or estimated GV) will be used for evaluation of the simulation results.}

\item{\code{traitNoEval}}{[numeric] Trait No of your interest for evaluation of the method}

\item{\code{hEval}}{[numeric] Hyperparameter which determines which BV is emphasized when evaluating simulation results of each method}

\item{\code{summaryAllResAt}}{[character] If NULL, we will summary the simulation results in `self$trueGVMatList` and `self$estimatedGVMatList`.
Else, we will summary the simulation results in `summaryAllResAt` path.}

\item{\code{verbose}}{[logical] Display info (optional)}

\item{\code{lociEffectsInit}}{[matrix] Marker and QTL effects used for crossInfo object for initial population}

\item{\code{hLens}}{[numeric] Length of hyperparameter vector}

\item{\code{hStart}}{[numeric] Initial values of hyper parameters}

\item{\code{solnInit}}{[list] List of solution of StoSOO for initial state}

\item{\code{hVecOptList}}{[list] List of optimized hyperparameters in each generation}

\item{\code{simBsRes}}{[list] Simulation results of each method}

\item{\code{trueGVMatInit}}{[matrix] A true GV matrix for initial population}

\item{\code{trueGVMatList}}{[list] A list of true GV matrix of simulation results}

\item{\code{trueGVSummaryArray}}{[array] An array of summary statistics of true GVs for each population & each iteration}

\item{\code{estimatedGVMatInit}}{[matrix] An estimated GV matrix for initial population}

\item{\code{estimatedGVMatList}}{[list] A list of estimated GV matrix of simulation results}

\item{\code{estimatedGVSummaryArray}}{[array] An array of summary statistics of estimated GVs for each population & each iteration}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{simBsOpt$new()}}
\item \href{#method-computeLociEffInit}{\code{simBsOpt$computeLociEffInit()}}
\item \href{#method-startSimulation}{\code{simBsOpt$startSimulation()}}
\item \href{#method-summaryResults}{\code{simBsOpt$summaryResults()}}
\item \href{#method-print}{\code{simBsOpt$print()}}
\item \href{#method-plot}{\code{simBsOpt$plot()}}
\item \href{#method-clone}{\code{simBsOpt$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new specie object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{simBsOpt$new(
  simBsName = "Undefined",
  bsInfoInit,
  breederInfoInit = NULL,
  lociEffMethod = NULL,
  methodMLRInit = NULL,
  multiTraitInit = FALSE,
  nIterSimulation = NULL,
  nGenerationProceed = NULL,
  nGenerationProceedSimulation = NULL,
  setGoalAsFinalGeneration = TRUE,
  performOptimization = NULL,
  useFirstOptimizedValue = NULL,
  sameAcrossGeneration = TRUE,
  hMin = NULL,
  hMax = NULL,
  nTotalIterForOneOptimization = NULL,
  nIterSimulationPerEvaluation = NULL,
  nIterOptimization = NULL,
  digitsEval = NULL,
  nRefreshMemoryEvery = NULL,
  updateBreederInfo = TRUE,
  phenotypingInds = FALSE,
  nRepForPhenoInit = NULL,
  nRepForPheno = NULL,
  updateModels = FALSE,
  methodMLR = NULL,
  multiTrait = FALSE,
  nSelectionWaysVec = NULL,
  selectionMethodList = NULL,
  traitNoSelList = NULL,
  blockSplitMethod = NULL,
  nMrkInBlock = NULL,
  minimumSegmentLength = NULL,
  nIterOPV = NULL,
  nProgeniesEMBVVec = NULL,
  nIterEMBV = NULL,
  nCoresEMBV = NULL,
  clusteringForSelList = FALSE,
  nClusterList = NULL,
  nTopClusterList = NULL,
  nTopEachList = NULL,
  nSelList = NULL,
  matingMethodVec = NULL,
  allocateMethodVec = NULL,
  weightedAllocationMethodList = NULL,
  traitNoRAList = NULL,
  includeGVPVec = FALSE,
  nNextPopVec = NULL,
  nameMethod = "pairBase",
  nCores = NULL,
  nCoresPerOptimization = NULL,
  overWriteRes = FALSE,
  showProgress = TRUE,
  returnMethod = "all",
  saveAllResAt = NULL,
  evaluateGVMethod = "true",
  traitNoEval = NULL,
  hEval = NULL,
  summaryAllResAt = NULL,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{simBsName}}{[character] Name of this simulation of breeding schemes}

\item{\code{bsInfoInit}}{[bsInfo] breeding scheme info
(see:\link[myBreedSimulatR]{bsInfo})}

\item{\code{breederInfoInit}}{[breederInfo] breeder info
(see:\link[myBreedSimulatR]{breederInfo})}

\item{\code{lociEffMethod}}{[character] How to compute loci effects (use true QTL effects ("true") or estimated marker effects ("estimated"))}

\item{\code{methodMLRInit}}{[character] Methods for estimating marker effects for initial population.
The following methods are offered:

"Ridge", "LASSO", "ElasticNet", "RR-BLUP", "GBLUP", "BayesA" (uni-trait),
"BayesB" (uni-trait), "BayesC" (uni-trait), "BRR", "BL" (uni-trait), "SpikeSlab" (multi-trait)}

\item{\code{multiTraitInit}}{[logical] Use multiple-trait model for estimation of marker effects or not for initial population}

\item{\code{nIterSimulation}}{[numeric] Number of iterations for this simulation setting}

\item{\code{nGenerationProceed}}{[numeric] Number of generations to be proceeded}

\item{\code{nGenerationProceedSimulation}}{[numeric] Number of generations to be proceeded in simulation for optimizing policy}

\item{\code{setGoalAsFinalGeneration}}{[logical] Set goal for simulation of breeding scheme as the real final generation}

\item{\code{performOptimization}}{[logical] Perform optimization of policy in each generation or not}

\item{\code{useFirstOptimizedValue}}{[logical] Perform optimization of policy only for the initial population and use the optimized hyperprameters permanently.}

\item{\code{sameAcrossGeneration}}{[logical] Use same hyper prameter across generations or not}

\item{\code{hMin}}{[numeric] Lower bound of hyper parameters}

\item{\code{hMax}}{[numeric] Upper bound of hyper parameters}

\item{\code{nTotalIterForOneOptimization}}{[numeric] Number of total iterations that can be assigned for one optimization process}

\item{\code{nIterSimulationPerEvaluation}}{[numeric] Number of simulations per one evaluation of the hyperparameter set of your interest}

\item{\code{nIterOptimization}}{[numeric] Number of iterations required for one optimization}

\item{\code{digitsEval}}{[numeric] When you evaluate each hyperparameter, you can round the average of evaluates (`eval`) with `round(eval, digitsEval)`.}

\item{\code{nRefreshMemoryEvery}}{[numeric] Every `nRefreshMemoryEvery` iterations, we refresh memory used for simulations by `gc(reset = TRUE)`.}

\item{\code{updateBreederInfo}}{[logical] Update breederInfo or not for each generation}

\item{\code{phenotypingInds}}{[logical] Phenotyping individuals or not for each generation}

\item{\code{nRepForPhenoInit}}{[numeric] Number of replications to be phenotyped for initial population}

\item{\code{nRepForPheno}}{[numeric] Number of replications to be phenotyped for each generation}

\item{\code{updateModels}}{[logical] Whether or not updating the model for each generation
(If `phenotypingInds = FALSE` for generation of your interest, `updateModels` will be automatically `FALSE` for that generation.)}

\item{\code{methodMLR}}{[character] Methods for estimating marker effects.
The following methods are offered:

"Ridge", "LASSO", "ElasticNet", "RR-BLUP", "GBLUP", "BayesA" (uni-trait),
"BayesB" (uni-trait), "BayesC" (uni-trait), "BRR", "BL" (uni-trait), "SpikeSlab" (multi-trait)}

\item{\code{multiTrait}}{[logical] Use multiple-trait model for estimation of marker effects or not}

\item{\code{nSelectionWaysVec}}{[numeric] Number of selection ways for each generation}

\item{\code{selectionMethodList}}{[list] (list of) Selection method for each generation}

\item{\code{traitNoSelList}}{[list] (list of list of) Number of trait No of your interest for selection for each generation}

\item{\code{blockSplitMethod}}{[character] How to determine the markers belonging to each block when computing OHV.
You can define the number of markers in each block (`nMrkInBlock`) or the minimum length of each segment (`minimumSegmentLength`).}

\item{\code{nMrkInBlock}}{[numeric] Number of markers in each block. This will be used for the computation of OHV.}

\item{\code{minimumSegmentLength}}{[numeric] Minimum length of each segment [cM]. This will be used for the computation of OHV.}

\item{\code{nIterOPV}}{[numeric] Number of iterations for computation of OPV}

\item{\code{nProgeniesEMBVVec}}{[numeric] Number of progenies of double haploids produced when computing EMBV for each generation}

\item{\code{nIterEMBV}}{[numeric] Number of iterations to estimate EMBV}

\item{\code{nCoresEMBV}}{[numeric] Number of cores used for EMBV estimation}

\item{\code{clusteringForSelList}}{[list] (list of) Apply clustering results of marker genotype to selection or not for each generation}

\item{\code{nClusterList}}{[list] (list of) Number of clusters for each generation}

\item{\code{nTopClusterList}}{[list] (list of) Number of top clusters used for selection for each generation}

\item{\code{nTopEachList}}{[list] (list of) Number of selected individuals in each cluster for each generation}

\item{\code{nSelList}}{[list] (list of) Number of selection candidates for each generation}

\item{\code{matingMethodVec}}{[character] Mating method for each generation}

\item{\code{allocateMethodVec}}{[character] Allocation method for each generation}

\item{\code{weightedAllocationMethodList}}{[list] (list of) Which selection index will be used for weighted resource allocation for each generation}

\item{\code{traitNoRAList}}{[list] (list of) Trait No of your interest for resource allocation for each generation}

\item{\code{includeGVPVec}}{[logical] Whether or not to consider genetic variance of progenies of each pair when determining the number of progenies per each pair for each generation}

\item{\code{nNextPopVec}}{[numeric] Number of progenies for the next generation  for each generation}

\item{\code{nameMethod}}{[character] Method for naming individuals}

\item{\code{nCores}}{[numeric] Number of cores used for simulations of breeding scheme}

\item{\code{nCoresPerOptimization}}{[numeric] Number of cores used for simulations of breeding scheme when optimizing hyperparameters}

\item{\code{overWriteRes}}{[logical] Overwrite simulation results when the targeted results already exists}

\item{\code{showProgress}}{[logical] Show progress bar or not}

\item{\code{returnMethod}}{[character] Which type of results will be returned (saved) in the object}

\item{\code{saveAllResAt}}{[character] If NULL, we won't save the simulation results. Else, we will save bsInfo and breederInfo for each iteration in the directory defined by `saveAllResAt` path.}

\item{\code{evaluateGVMethod}}{[character] Which type of GV (true GV or estimated GV) will be used for evaluation of the simulation results}

\item{\code{traitNoEval}}{[numeric] Trait No of your interest for evaluation of the method}

\item{\code{hEval}}{[numeric] Hyperparameter which determines which BV is emphasized when evaluating simulation results of each method}

\item{\code{summaryAllResAt}}{[character] If NULL, we will summary the simulation results in `self$trueGVMatList` and `self$estimatedGVMatList`.
Else, we will summary the simulation results in `summaryAllResAt` path.}

\item{\code{verbose}}{[logical] Display info (optional)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new `simBs` object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{### create simulation information
mySimInfo <- simInfo$new(simName = "Simulation Example",
                         simGeno = TRUE,
                         simPheno = TRUE,
                         #' nSimGeno = 1,
                         #' nSimPheno = 3,
                         #' nCoreMax = 4,
                         #' nCorePerGeno = 1,
                         #' nCorePerPheno = 3,
                         saveDataFileName = NULL)
### create specie information
mySpec <- specie$new(nChr = 3,
                     lChr = c(100, 150, 200),
                     specName = "Example 1",
                     ploidy = 2,
                     mutRate = 10^-8,
                     recombRate = 10^-6,
                     chrNames = c("C1", "C2", "C3"),
                     nLoci = 100,
                     recombRateOneVal = FALSE,
                     effPopSize = 100,
                     simInfo = mySimInfo,
                     verbose = TRUE)
### create lociInfo object
myLoci <- lociInfo$new(genoMap = NULL, specie = mySpec)
plot(myLoci, alpha = 0.1)
### create traitInfo object
myTrait <- traitInfo$new(lociInfo = myLoci,
                         nMarkers = 80,
                         nTraits = 3,
                         nQTLs = c(4, 8, 3),
                         actionTypeEpiSimple = TRUE,
                         qtlOverlap = TRUE,
                         nOverlap = c(2, 3, 0),
                         effCor = 0.1,
                         propDomi = 0.2,
                         interactionMean = c(4, 1, 2))
myTrait$plot(alphaMarker = 0.1)
### create bsInfo object
myBsInfo <- bsInfo$new(simInfo = mySimInfo,
                       specie = mySpec,
                       lociInfo = myLoci,
                       traitInfo = myTrait,
                       geno = NULL,
                       haplo = NULL,
                       founderIsInitPop = TRUE,
                       popNameBase = "Population",
                       initIndNames = NULL,
                       verbose = TRUE)
### create cross information object
for (i in 1:10) {
  myCrossInfo <- crossInfo$new(parentPopulation = myBsInfo$populations[[myBsInfo$generation]],
                               method = "randomMate",
                               nNextPop = 100)
  myBsInfo$nextGeneration(crossInfo = myCrossInfo)
}
geno <- myBsInfo$overGeneration()$genoMat
myBsInfo$print()
myBsInfo$plot(plotTarget = "trueAGV",
              targetTrait = 1:3,
              targetPopulation = 1:11,
              plotType = "jitter")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-computeLociEffInit"></a>}}
\if{latex}{\out{\hypertarget{method-computeLociEffInit}{}}}
\subsection{Method \code{computeLociEffInit()}}{
estimate/extract marker/QTL effects information
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{simBsOpt$computeLociEffInit()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-startSimulation"></a>}}
\if{latex}{\out{\hypertarget{method-startSimulation}{}}}
\subsection{Method \code{startSimulation()}}{
start simulation of breeding scheme
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{simBsOpt$startSimulation()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-summaryResults"></a>}}
\if{latex}{\out{\hypertarget{method-summaryResults}{}}}
\subsection{Method \code{summaryResults()}}{
start simulation of breeding scheme
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{simBsOpt$summaryResults()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Display information about the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{simBsOpt$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
Draw figures for visualization of simulation results for summary statistics
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{simBsOpt$plot(
  targetTrait = 1,
  targetPopulation = NULL,
  plotType = "box",
  plotTargetDensity = "max",
  plotGVMethod = "true",
  adjust = 1e-05
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{targetTrait}}{[numeric] Target trait. character is OK, but numeric vector
corresponding to target traits is preferred. It should be a vector with length 1.}

\item{\code{targetPopulation}}{[numeric] Target populations. character is OK, but numeric vector
corresponding to target traits is preferred.}

\item{\code{plotType}}{[character] We offer "box", "violin", "lines", "density"
to draw figures for simulation results.}

\item{\code{plotTargetDensity}}{[character] When you choose "density" for `plotType`,
you should select which summary statistics will be plotted. It should be a vector with length 1.}

\item{\code{plotGVMethod}}{[character] Which type of GV (true GV or estimated GV) will be used for plotting the simulation results}

\item{\code{adjust}}{[numeric] the bandwidth used is actually adjust*bw. This makes it easy to specify values like ‘half the default’ bandwidth.
(see: `adjust` in \link[stats]{density})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{simBsOpt$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
