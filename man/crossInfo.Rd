% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/myCross.R
\name{crossInfo}
\alias{crossInfo}
\title{R6 class representing a crossing information}
\description{
crossInfo object store specific crossing information
}
\examples{

## ------------------------------------------------
## Method `crossInfo$new`
## ------------------------------------------------

### create simulation information
mySimInfo <- simInfo$new(simName = "Simulation Example",
                         simGeno = TRUE,
                         simPheno = TRUE,
                         nSimGeno = 1,
                         nSimPheno = 3,
                         nCoreMax = 4,
                         nCorePerGeno = 1,
                         nCorePerPheno = 3,
                         saveDataFileName = NULL)

### create specie information
mySpec <- specie$new(nChr = 3,
                     lChr = c(100, 150, 200),
                     specName = "Example 1",
                     ploidy = 2,
                     mutRate = 10^-8,
                     recombRate = 10^-6,
                     chrNames = c("C1", "C2", "C3"),
                     nLoci = 100,
                     recombRateOneVal = FALSE,
                     effPopSize = 100,
                     simInfo = mySimInfo,
                     verbose = TRUE)

### create lociInfo object
myLoci <- lociInfo$new(genoMap = NULL, specie = mySpec)


### create simulated population
simulatedPop <- createPop(geno = NULL,
                          haplo = NULL,
                          lociInfo = myLoci,
                          founderIsInitPop = TRUE,
                          popName = "First Population",
                          verbose = FALSE)


### create cross oinformation object
myCrossInfo <- crossInfo$new(parentPopulation = simulatedPop,
                             selectionMethod = "nonSelection",
                             matingMethod = "randomMate",
                             nNextPop = 100)
print(myCrossInfo)
myCrossInfo$designResourceAllocation()
newIndsList <- myCrossInfo$makeCrosses
}
\references{
Jannink, Jean-Luc. “Dynamics of Long-Term Genomic Selection.”
  Genetics Selection Evolution 42, no. 1 (December 2010).
  https://doi.org/10.1186/1297-9686-42-35.

Daetwyler, H.D., Hayden, M.J., Spangenberg, G.C. and Hayes, B.J. (2015)
Selection on optimal haploid value increases genetic gain and preserves more genetic diversity relative to genomic selection.
Genetics. 200(4): 1341-1348.

Müller, D., Schopp, P. and Melchinger, A.E. (2018)
Selection on expected maximum haploid breeding values can increase genetic gain in recurrent genomic selection.
G3 (Bethesda). 8(4): 1173-1181.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{parentPopulation}}{[population class] Parent population that will generatea new population of the next generation}

\item{\code{nSelectionWays}}{[numeric] Number of selection ways}

\item{\code{selectionMethod}}{[character] Selection method}

\item{\code{traitNoSel}}{[numeric / list] (list of) number of trait No of your interest for selection}

\item{\code{userSI}}{[matrix] Selection index defined by user. If you set `userSI` and `selectionMethod = 'userSI'`,
this argument will be used for selection. The number of rows equals to the number of individuals.
If you have multiple traits, it will be a matrix of multiple columns.}

\item{\code{lociEffects}}{[matrix] Effect of the genetic markers (including intercept).
If you have multiple traits, it will be a matrix of multiple columns.}

\item{\code{blockSplitMethod}}{[character] How to determine the markers belonging to each block when computing OHV.
You can define the number of markers in each block (`nMrkInBlock`) or the minimum length of each segment (`minimumSegmentLength`).}

\item{\code{nMrkInBlock}}{[numeric] Number of markers in each block. This will be used for the computation of OHV.}

\item{\code{minimumSegmentLength}}{[numeric] Minimum length of each segment [cM]. This will be used for the computation of OHV.}

\item{\code{nSelInitOPV}}{[numeric] Number of selected candiates for first screening before selecting parent candidates by OPV}

\item{\code{nIterOPV}}{[numeric] Number of iterations for computation of OPV}

\item{\code{nProgeniesEMBV}}{[numeric] Number of progenies of double haploids produced when computing EMBV}

\item{\code{nIterEMBV}}{[numeric] Number of iterations to estimate EMBV}

\item{\code{nCoresEMBV}}{[numeric] Number of cores used for EMBV estimation}

\item{\code{clusteringForSel}}{[logical] Apply clustering results of marker genotype to selection or not}

\item{\code{nCluster}}{[numeric] Number of clusters}

\item{\code{nTopCluster}}{[numeric] Number of top clusters used for selection}

\item{\code{nTopEach}}{[numeric] Number of selected individuals in each cluster}

\item{\code{nSel}}{[numeric] Number of selection candidates}

\item{\code{multiTraitsEvalMethod}}{[character] When evaluating multiple traits, you can choose how to evaluate these traits simultaneously.
One method is to take a weighted sum of these traits, and the other is to compute a product of these traits (adjusted to be positive values in advance.)}

\item{\code{hSel}}{[numeric] Hyperparameter which determines which trait is weighted when selecting parent candidates for multiple traits.}

\item{\code{matingMethod}}{[character] Mating method}

\item{\code{allocateMethod}}{[character] Allocation method}

\item{\code{weightedAllocationMethod}}{[character] Which selection index will be used for weighted resource allocation}

\item{\code{nProgenies}}{[numeric] Number of progenies for each pair}

\item{\code{traitNoRA}}{[numeric] trait No of your interest for resource allocation}

\item{\code{h}}{[numeric] Hyperprameter which determines how parent pair with high BV is emphasized when producing progenies}

\item{\code{includeGVP}}{[logical] Whether or not to consider genetic variance of progenies of each pair when determining the number of progenies per each pair}

\item{\code{nNextPop}}{[numeric] Number of progenies for the next generation}

\item{\code{nPairs}}{[numeric] Number of parent pairs for the next generation}

\item{\code{nameMethod}}{[character] Method for naming individuals}

\item{\code{indNames}}{[character] Character string vector specifying the individuals names
of the new population}

\item{\code{seedSimRM}}{[numeric] Random seed for mate pairs}

\item{\code{seedSimMC}}{[numeric] Random seed for make crosses}

\item{\code{selCands}}{[character] Names of selection candidates}

\item{\code{crosses}}{[data.frame] data.frame with crossing instructions: parents names
\code{ind1} \code{ind2}, number of descendant \code{n} and names of
descendant \code{names}}

\item{\code{genDist}}{[dist] `dist` object of genetic distance computed from marker genotype by Euclidean distance}

\item{\code{groups}}{[list] List of named vectors of group IDs of each individual categorized by hierarchical clustering}

\item{\code{BV}}{[matrix] matrix of the breeding values}

\item{\code{WBV}}{[matrix] matrix of the weighted breeding values}

\item{\code{OHV}}{[matrix] matrix of the optimal haploid values}

\item{\code{EMBV}}{[matrix] matrix of the expected maximum haploid breeding values}

\item{\code{haploEffMaxArray}}{[array] haploid value of each segment (haplotype block) for each individual}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{computeBV}}{[matrix] matrix of the breeding values}

\item{\code{computeWBV}}{[matrix] matrix of the weighted breeding values}

\item{\code{computeOHV}}{[matrix] matrix of the optimal haploid values}

\item{\code{computeEMBV}}{[matrix] matrix of the expected maximum haploid breeding values}

\item{\code{randomMate}}{[data.frame] \code{data.frame} of the crossing table by random mating}

\item{\code{roundRobin}}{[data.frame] \code{data.frame} of the crossing table by round-robin}

\item{\code{diallel}}{[data.frame] \code{data.frame} of the crossing table by diallel}

\item{\code{diallelWithSelfing}}{[data.frame] \code{data.frame} of the crossing table by diallel with selfing}

\item{\code{selfing}}{[data.frame] \code{data.frame} of the crossing table by selfing}

\item{\code{maxGenDist}}{[data.frame] \code{data.frame} of the crossing table by mating pairs whose genetic distance is maximum}

\item{\code{makeDH}}{[data.frame] \code{data.frame} of the crossing table by makeDH}

\item{\code{makeCrosses}}{[list] return a list of new individuals}

\item{\code{makeDHs}}{[list] return a list of new double haploids}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{crossInfo$new()}}
\item \href{#method-computeGenDist}{\code{crossInfo$computeGenDist()}}
\item \href{#method-hClustering}{\code{crossInfo$hClustering()}}
\item \href{#method-selectParentCands}{\code{crossInfo$selectParentCands()}}
\item \href{#method-allocateProgenies}{\code{crossInfo$allocateProgenies()}}
\item \href{#method-designResourceAllocation}{\code{crossInfo$designResourceAllocation()}}
\item \href{#method-print}{\code{crossInfo$print()}}
\item \href{#method-clone}{\code{crossInfo$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new population object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$new(
  parentPopulation,
  nSelectionWays = NA,
  selectionMethod = "nonSelection",
  traitNoSel = NULL,
  userSI = NULL,
  lociEffects = NULL,
  blockSplitMethod = NULL,
  nMrkInBlock = NULL,
  minimumSegmentLength = NULL,
  nSelInitOPV = NULL,
  nIterOPV = NULL,
  nProgeniesEMBV = NULL,
  nIterEMBV = NULL,
  nCoresEMBV = NULL,
  clusteringForSel = FALSE,
  nCluster = NULL,
  nTopCluster = NULL,
  nTopEach = NULL,
  nSel = NULL,
  multiTraitsEvalMethod = NULL,
  hSel = NULL,
  matingMethod = "randomMate",
  allocateMethod = "equalAllocation",
  weightedAllocationMethod = NULL,
  nProgenies = NULL,
  traitNoRA = NULL,
  h = NULL,
  includeGVP = FALSE,
  nNextPop = NULL,
  nPairs = NULL,
  nameMethod = "pairBase",
  indNames = NULL,
  seedSimRM = NA,
  seedSimMC = NA,
  selCands = NULL,
  crosses = NULL,
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{parentPopulation}}{[population class] Parent population that will generate a new population of the next generation}

\item{\code{nSelectionWays}}{[numeric] Number of selection ways}

\item{\code{selectionMethod}}{[character] Selection method}

\item{\code{traitNoSel}}{[numeric / list] (list of) number of trait No of your interest for selection}

\item{\code{userSI}}{[matrix] Selection index defined by user. If you set `userSI` and `selectionMethod = 'userSI'`,
this argument will be used for selection. The number of rows equals to the number of individuals.
If you have multiple traits, it will be a matrix of multiple columns.}

\item{\code{lociEffects}}{[matrix] Effect of the genetic markers (including intercept).
If you have multiple traits, it will be a matrix of multiple columns.}

\item{\code{blockSplitMethod}}{[character] How to determine the markers belonging to each block when computing OHV.
You can define the number of markers in each block (`nMrkInBlock`) or the minimum length of each segment (`minimumSegmentLength`).}

\item{\code{nMrkInBlock}}{[numeric] Number of markers in each block. This will be used for the computation of OHV.}

\item{\code{minimumSegmentLength}}{[numeric] Minimum length of each segment [cM]. This will be used for the computation of OHV.}

\item{\code{nSelInitOPV}}{[numeric] Number of selected candiates for first screening before selecting parent candidates by OPV}

\item{\code{nIterOPV}}{[numeric] Number of iterations for computation of OPV}

\item{\code{nProgeniesEMBV}}{[numeric] Number of progenies of double haploids produced when computing EMBV}

\item{\code{nIterEMBV}}{[numeric] Number of iterations to estimate EMBV}

\item{\code{nCoresEMBV}}{[numeric] Number of cores used for EMBV estimation}

\item{\code{clusteringForSel}}{[logical] Apply clustering results of marker genotype to selection or not}

\item{\code{nCluster}}{[numeric] Number of clusters}

\item{\code{nTopCluster}}{[numeric] Number of top clusters used for selection}

\item{\code{nTopEach}}{[numeric] Number of selected individuals in each cluster}

\item{\code{nSel}}{[numeric] Number of selection candidates}

\item{\code{multiTraitsEvalMethod}}{[character] When evaluating multiple traits, you can choose how to evaluate these traits simultaneously.
One method is to take a weighted sum of these traits, and the other is to compute a product of these traits (adjusted to be positive values in advance.)}

\item{\code{hSel}}{[numeric] Hyperparameter which determines which trait is weighted when selecting parent candidates for multiple traits.}

\item{\code{matingMethod}}{[character] Mating method}

\item{\code{allocateMethod}}{[character] Allocation method}

\item{\code{weightedAllocationMethod}}{[character] Which selection index will be used for weighted resource allocation}

\item{\code{nProgenies}}{[numeric] Number of progenies for each pair}

\item{\code{traitNoRA}}{[numeric] Trait No of your interest for resource allocation}

\item{\code{h}}{[numeric] Hyperparameter which determines how parent pair with high BV is emphasized when producing progenies}

\item{\code{includeGVP}}{[logical] Whether or not to consider genetic variance of progenies of each pair when determining the number of progenies per each pair}

\item{\code{nNextPop}}{[numeric] Number of progenies for the next generation}

\item{\code{nPairs}}{[numeric] Number of parent pairs for the next generation}

\item{\code{nameMethod}}{[character] Method for naming individuals}

\item{\code{indNames}}{[character] Character string vector specifying the individuals names
of the new population}

\item{\code{seedSimRM}}{[numeric] Random seed for mate pairs}

\item{\code{seedSimMC}}{[numeric] Random seed for make crosses}

\item{\code{selCands}}{[character] Names of selection candidates}

\item{\code{crosses}}{[data.frame] data.frame with crossing instructions: parents names
\code{ind1} \code{ind2}, number of descendant \code{n} and names of
descendant \code{names}}

\item{\code{verbose}}{[boolean] display information}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new `population` object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{### create simulation information
mySimInfo <- simInfo$new(simName = "Simulation Example",
                         simGeno = TRUE,
                         simPheno = TRUE,
                         nSimGeno = 1,
                         nSimPheno = 3,
                         nCoreMax = 4,
                         nCorePerGeno = 1,
                         nCorePerPheno = 3,
                         saveDataFileName = NULL)

### create specie information
mySpec <- specie$new(nChr = 3,
                     lChr = c(100, 150, 200),
                     specName = "Example 1",
                     ploidy = 2,
                     mutRate = 10^-8,
                     recombRate = 10^-6,
                     chrNames = c("C1", "C2", "C3"),
                     nLoci = 100,
                     recombRateOneVal = FALSE,
                     effPopSize = 100,
                     simInfo = mySimInfo,
                     verbose = TRUE)

### create lociInfo object
myLoci <- lociInfo$new(genoMap = NULL, specie = mySpec)


### create simulated population
simulatedPop <- createPop(geno = NULL,
                          haplo = NULL,
                          lociInfo = myLoci,
                          founderIsInitPop = TRUE,
                          popName = "First Population",
                          verbose = FALSE)


### create cross oinformation object
myCrossInfo <- crossInfo$new(parentPopulation = simulatedPop,
                             selectionMethod = "nonSelection",
                             matingMethod = "randomMate",
                             nNextPop = 100)
print(myCrossInfo)
myCrossInfo$designResourceAllocation()
newIndsList <- myCrossInfo$makeCrosses
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-computeGenDist"></a>}}
\if{latex}{\out{\hypertarget{method-computeGenDist}{}}}
\subsection{Method \code{computeGenDist()}}{
Compute genetic distance from marker genotype
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$computeGenDist()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-hClustering"></a>}}
\if{latex}{\out{\hypertarget{method-hClustering}{}}}
\subsection{Method \code{hClustering()}}{
Hierarchical clustering for marker genotype
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$hClustering(nCluster = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nCluster}}{[numeric] Number of clusters}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-selectParentCands"></a>}}
\if{latex}{\out{\hypertarget{method-selectParentCands}{}}}
\subsection{Method \code{selectParentCands()}}{
Select parent candidates
If you set `addCands = TRUE`, you can add selection candidates by setting each parameter.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$selectParentCands(
  nSelectionWaysPlus = NA,
  selectionMethod = NULL,
  traitNoSel = NULL,
  nSelInitOPV = NULL,
  clusteringForSel = NULL,
  nCluster = NULL,
  nTopCluster = NULL,
  nTopEach = NULL,
  nSel = NULL,
  multiTraitsEvalMethod = NULL,
  hSel = NULL,
  parentCands = NULL,
  addCands = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nSelectionWaysPlus}}{[numeric] Number of selection ways when you want to add candidates}

\item{\code{selectionMethod}}{[character] Selection method when you want to add candidates}

\item{\code{traitNoSel}}{[numeric / list] (list of) number of trait No of your interest for selection when you want to add candidates}

\item{\code{nSelInitOPV}}{[numeric] Number of selected candiates for first screening before selecting parent candidates by OPV}

\item{\code{clusteringForSel}}{[logical] Apply clustering results of marker genotype to selection or not when you want to add candidates}

\item{\code{nCluster}}{[numeric] Number of clusters when you want to add candidates}

\item{\code{nTopCluster}}{[numeric] Number of top clusters used for selection when you want to add candidates}

\item{\code{nTopEach}}{[numeric] Number of selected individuals in each cluster when you want to add candidates}

\item{\code{nSel}}{[numeric] Number of selection candidates when you want to add candidates}

\item{\code{multiTraitsEvalMethod}}{[character] When evaluating multiple traits, you can choose how to evaluate these traits simultaneously.
One method is to take a weighted sum of these traits, and the other is to compute a product of these traits (adjusted to be positive values in advance.)}

\item{\code{hSel}}{[numeric] Hyperparameter which determines which trait is weighted when selecting parent candidates for multiple traits.}

\item{\code{parentCands}}{[character] Names of selection candidates to be added}

\item{\code{addCands}}{[logical] If you set `addCands = TRUE`, you can add selection candidates by setting each parameter.
In other words, the parameters above does not make sense.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-allocateProgenies"></a>}}
\if{latex}{\out{\hypertarget{method-allocateProgenies}{}}}
\subsection{Method \code{allocateProgenies()}}{
Allocate the number of progenies to each parent pair
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$allocateProgenies(crosses0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{crosses0}}{[data.frame] data.frame with crossing instructions: parents names
\code{ind1} \code{ind2}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-designResourceAllocation"></a>}}
\if{latex}{\out{\hypertarget{method-designResourceAllocation}{}}}
\subsection{Method \code{designResourceAllocation()}}{
Design resource allocation (make cross table)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$designResourceAllocation()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Display informations about the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crossInfo$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
